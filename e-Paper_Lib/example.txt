/*	сохраняем данный файл в кодировке UTF-8		*/

/*			НАСТРОЙКИ CubeMX:
		1) 	ставим режим SPI Transmit Only Master
		2) 	скорость рекомендуют не больше 2 МБит/с ( но у меня работало и с 42 МБит/с ) коректируем под работу дисплея
		3) 	ВАЖНО в коде создается массив с размер экрана для 1,54 с разрешением 200 на 200 пикселей будет массив 200*200 = 40000 Байт( 40 Кбайт )
			этот размер выделяеться в оперативной памяти, длдя етого нам нужно увеличить размер кучи ( Minimum Heap Size ) 0xC350
			для большего разрешения экрана выделяем больше
		4)  немного увеличиваем и размер стека 0x1000
		5)  устанавливаем 3 порта ( DC RST CS ) на выход и 1 ( BUSY ) на вход
			называем их как тут чтобы в коде нечего не менять.
		6)  подключаем к проекту следующие пути к файлам:		
				..\e-Paper\Config;                             
				..\e-Paper\e-Paper;                             
				..\e-Paper\Fonts;                             
				..\e-Paper\GUI;                             
				
		7)	Далее подключаем в проект файлы с каталога \Config ->  Debug.h  DEV_Config.h  DEV_Config.c
		8)	Далее подключаем в проект файлы с каталога \e-Paper ->  файлы .h .c которые относяться к нашему дисплею ( для моего 1,54V2 )
		9)	Далее подключаем в проект файлы с каталога \Fonts -> подключаем шрифты которые будем использовать
		10)	Далее подключаем в проект файлы с каталога \GUI -> GUI_Paint.c  GUI_Paint.h
			
		в файле fonts.h нужно выбрать шрифты:

		//---- для экономии памяти шрифты которые не используються закоментировать -------------------------------------
					// Шрифт имеет кирилицу и латиницу
					#define FONT_6x8		//  6 x 8 pixels font size structure 
					#define FONT_7x9		//  7 x 9 pixels font size structure 
					#define FONT_11x18		//  11 x 18 pixels font size structure 
					#define FONT_16x26		//  16 x 26 pixels font size structure 
					// Только цифры -- only numbers
					#define FONT_16x28		//  16 x 28 pixels font size structure only numbers	
		//--------------------------------------------------------------------------------------------------------------
		//---------------------------------------------------------------------------------------
		
		
		Далее в файле DEV_Config.h делаем настройки:
		
		//###########  SETUP	#######################################################
		
				// указываем порт SPI для HAL -------------------
					
				#define DEV_SPI_HAL 			hspi1
				
				//-----------------------------------------------
					
				//============================================================================
				
				//=== указываем порты ( если в кубе назвали их DC RES CS то тогда нечего указывать не нужно )
				#if defined (DC_GPIO_Port)	// OUTPUT
				#else
					#define DC_GPIO_Port	GPIOA
					#define DC_Pin			GPIO_PIN_11
				#endif
				
				#if defined (RST_GPIO_Port) // OUTPUT
				#else
					#define RST_GPIO_Port   GPIOA
					#define RST_Pin			GPIO_PIN_12
				#endif
				
				#if defined (CS_GPIO_Port) // OUTPUT
				#else
					#define CS_GPIO_Port   	GPIOA
					#define CS_Pin			GPIO_PIN_13
				#endif
				
				#if defined (BUSY_GPIO_Port) // INPUT
				#else
					#define BUSY_GPIO_Port  GPIOA
					#define BUSY_Pin		GPIO_PIN_14
				#endif
		

		//#############################################################################

*/






//----------------------------------------------------------------

#include "DEV_Config.h"
#include "GUI_Paint.h"
#include <stdlib.h> // malloc() free()

// тут подключаем фаил нашего дисплея
#include "EPD_1in54_V2.h"	

//----------------------------------------------------------------




	.........
	.........

main()=============================================================================================================================

	.........
	.........
	.........
	
//##########################################################################

// устанавливаем пины DC RST CS в нужный уровень
DEV_Module_Init();

// инициализация: его следует использовать для инициализации 
// электронной бумаги или пробуждения электронной бумаги из спящего режима.
EPD_1IN54_V2_Init();

// очистить дисплей: эта функция используется для очистки электронной бумаги до белого
EPD_1IN54_V2_Clear();

// ждем
DEV_Delay_ms(500);

// создаем указатель на массив который будем заполнять и выводить на экранразмера 
UBYTE *BlackImage;

// создаем массив ( выделяем память размером высота * ширину разрешения дисплея )
// так как будет использована динамическая память увеличиваем в проекте размер кучи Heap
UWORD Imagesize = ((EPD_1IN54_V2_WIDTH % 8 == 0)? (EPD_1IN54_V2_WIDTH / 8 ): (EPD_1IN54_V2_WIDTH / 8 + 1)) * EPD_1IN54_V2_HEIGHT;

// проверяем была ли выделена память или нет
if((BlackImage = (UBYTE *)malloc(Imagesize)) == NULL) {
     // если память небыла выделена
}

// если память выделилась

// заполняем буффер но не выводим на дисплей
// эта функция используется для создания нового изображения с шириной, высотой, градусом поворота и его цветом.
Paint_NewImage(BlackImage, EPD_1IN54_V2_WIDTH, EPD_1IN54_V2_HEIGHT, ROTATE_270, WHITE);

// выбераем буффер для вывода на дисплей но не выводим ( буфферов можно делато много )
// эта функция используется для выбора буфера изображения. Вы можете создать несколько буферов 
// изображений с последней функцией, а затем выбрать буфер для каждого изображения.
Paint_SelectImage(BlackImage);

// выводим на дисплей данные хранящиеся в буффере ( в данном примере полностью закрашенный экран черным )
// Передача кадра изображения и отображения
EPD_1IN54_V2_Display(BlackImage);

// ждем
DEV_Delay_ms(2000);

// очищаем дисплей заполняем созданный и выбранный выше буффер белым цветом но невыводим на дисплей
// эта функция используется для очистки экрана до определенного цвета.
Paint_Clear(WHITE);

// выводим на дисплей заполненый выше буффер  ( заполненый белым цветом )
// Передача кадра изображения и отображения
EPD_1IN54_V2_Display(BlackImage);

// ждем
DEV_Delay_ms(2000);
			
			//------------------------------
				#include "..\Examples\imagedata.h"
				// заполняем в буффер картинку размером 200 на 200 с именем gImage_1in54 но не выводим
				// отправить данные изображения из файла bmp в буфер
				Paint_DrawBitMap(gImage_1in54);
			//-------------------------------
			
			
// выводим на дисплей картинку заполненую в буффер выше
// Передача кадра изображения и отображения
EPD_1IN54_V2_Display(BlackImage);

// ждем
DEV_Delay_ms(4000);
		
		// выводим свою картинку двумя методами-------------------------------------------------
		Paint_Clear(WHITE);
		// подключаем в проект новую папку для вывода другой картинки ..\e-Paper\LOGO\black
		// подключаем фаил Logo.c к проекту
		extern const unsigned char gImage_Logo[5000];
		// заполняем в буффер картинку размером 200 на 200 с именем gImage_Logo но не выводим
		// отправить данные изображения из файла bmp в буфер
		// картинка должна быть строго размером на всесь дисплей 200 на 200 выводит инвертируемую
		// для етого делаем массив картинки там где должно быть черное ставим белое и наоборот
		// данный метод не поддерживает ротацию и не поддерживает отзеркаливание
			// Paint_DrawBitMap(gImage_Logo);
		
		// вариант второй выводим любой размер картинки ( при етом выводит как есть белое белым  и черное черным )
		// данный метод также поддерживает ротацию и отзеркаливание
		// выводим любой размер картинки, начальные координаты, массив с картинкой, размер ширина и высота картинки, цвет
			Paint_DrawBitMap_Size( 0, 0, gImage_Logo, 200, 200, BLACK );
		//--------------------------------------------------------------------------------------


// выводим на дисплей картинку заполненую в буффер выше
// Передача кадра изображения и отображения
EPD_1IN54_V2_Display(BlackImage);

// ждем
DEV_Delay_ms(5000);

Paint_SelectImage(BlackImage);
Paint_Clear(WHITE);

// -- линии кружки точки треугольники цифры строки ----------------------------------------
	// формируем изображение ( забываем буффер  данными ) но не выводим на дисплей
	// ширина линий и точек 	DOT_PIXEL_1X1 	DOT_PIXEL_2X2		DOT_PIXEL_3X3	DOT_PIXEL_4X4	DOT_PIXEL_5X5	DOT_PIXEL_6X6	DOT_PIXEL_7X7	DOT_PIXEL_8X8
	Paint_DrawPoint(5, 10, BLACK, DOT_PIXEL_1X1, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
    Paint_DrawPoint(5, 25, BLACK, DOT_PIXEL_2X2, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
    Paint_DrawPoint(5, 40, BLACK, DOT_PIXEL_3X3, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
    Paint_DrawPoint(5, 55, BLACK, DOT_PIXEL_4X4, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии

	Paint_DrawLine(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
    Paint_DrawLine(70, 10, 20, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
    Paint_DrawLine(170, 15, 170, 55, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
    Paint_DrawLine(150, 35, 190, 35, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная

	Paint_DrawRectangle(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем прямоугольник пустотелый
    Paint_DrawRectangle(85, 10, 130, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем прямоугольник закрашенный

	Paint_DrawCircle(170, 35, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем круг пустотелый
    Paint_DrawCircle(170, 85, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем круг закрашенный
	
	// печатаем строку параметры: х,  у,  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка
	// для кирилицы используем функцию utf8rus, если только латиница то можно без нее
	Paint_DrawString( 5, 85, BLACK, WHITE, 1, &Font_7x9, 1, "waveshare" );
	// незабываем каждый раз после вызова функции utf8rus() освобождать память
	// free( pText );	// освобождаем память выделенную в функции utf8rus() посредством malloc();
	
	// печатаем число
	char str[20];
	sprintf(str, "%d", 123456789 );
	Paint_DrawString( 5, 110, BLACK, WHITE, 1, &Font_7x9, 1, str );

	Paint_SetPixel( 190, 190, BLACK );	// рисуем 1 пиксель координаты и цвет
	
	// выводим на дисплей заполненый выше буффер
	EPD_1IN54_V2_Display(BlackImage);
    DEV_Delay_ms(2000);
//----------------------------------------------------------------------------------------


////--- работает со всем кроме картинки ------------------------
//// эта функция используется для установки степени поворота, обычно она используется после Paint_SelectImage (). 
//// Вы можете установить угол поворота на 0、90、180、270 градусов.
//Paint_SetRotate(ROTATE_0);

//Paint_Clear(WHITE);
// формируем изображение ( забываем буффер  данными ) но не выводим на дисплей
//	// ширина линий и точек 	DOT_PIXEL_1X1 	DOT_PIXEL_2X2		DOT_PIXEL_3X3	DOT_PIXEL_4X4	DOT_PIXEL_5X5	DOT_PIXEL_6X6	DOT_PIXEL_7X7	DOT_PIXEL_8X8
//	Paint_DrawPoint(5, 10, BLACK, DOT_PIXEL_1X1, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 25, BLACK, DOT_PIXEL_2X2, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 40, BLACK, DOT_PIXEL_3X3, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 55, BLACK, DOT_PIXEL_4X4, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии

//	Paint_DrawLine(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(70, 10, 20, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(170, 15, 170, 55, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(150, 35, 190, 35, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная

//	Paint_DrawRectangle(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем прямоугольник пустотелый
//    Paint_DrawRectangle(85, 10, 130, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем прямоугольник закрашенный

//	Paint_DrawCircle(170, 35, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем круг пустотелый
//    Paint_DrawCircle(170, 85, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем круг закрашенный
//	
//	// печатаем строку параметры: х,  у,  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка
//	// для кирилицы используем функцию utf8rus, если только латиница то можно без нее
//	Paint_DrawString( 5, 85, BLACK, WHITE, 1, &Font_7x9, 1, "waveshare" );
//	// незабываем каждый раз после вызова функции utf8rus() освобождать память
//	// free( pText );	// освобождаем память выделенную в функции utf8rus() посредством malloc();
//	
//	// печатаем число
//	char str1[20];
//	sprintf(str1, "%d", 123456789 );
//	Paint_DrawString( 5, 110, BLACK, WHITE, 1, &Font_7x9, 1, str );

//	Paint_SetPixel( 190, 190, BLACK );	// рисуем 1 пиксель координаты и цвет
//	
//	// выводим на дисплей заполненый выше буффер
//	EPD_1IN54_V2_Display(BlackImage);
//    DEV_Delay_ms(2000);
//---------------------------------------------------------------------------------

////--- работает со всем кроме картинки ---------------------
//// эта функция используется для зеркального отображения изображений.
//// MIRROR_HORIZONTAL   MIRROR_VERTICAL   MIRROR_ORIGIN      MIRROR_NONE
//Paint_SetMirroring(MIRROR_HORIZONTAL);

//Paint_Clear(WHITE);
// формируем изображение ( забываем буффер  данными ) но не выводим на дисплей
//	// ширина линий и точек 	DOT_PIXEL_1X1 	DOT_PIXEL_2X2		DOT_PIXEL_3X3	DOT_PIXEL_4X4	DOT_PIXEL_5X5	DOT_PIXEL_6X6	DOT_PIXEL_7X7	DOT_PIXEL_8X8
//	Paint_DrawPoint(5, 10, BLACK, DOT_PIXEL_1X1, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 25, BLACK, DOT_PIXEL_2X2, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 40, BLACK, DOT_PIXEL_3X3, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии
//    Paint_DrawPoint(5, 55, BLACK, DOT_PIXEL_4X4, DOT_STYLE_DFT);	// рисуем линию Х  У  толшина линии (пиксель на пиксель ) стиль линии

//	Paint_DrawLine(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(70, 10, 20, 60, BLACK, DOT_PIXEL_1X1, LINE_STYLE_SOLID);		// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(170, 15, 170, 55, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная
//    Paint_DrawLine(150, 35, 190, 35, BLACK, DOT_PIXEL_1X1, LINE_STYLE_DOTTED);	// рисуем линию Х У начала   Х У конца  цвет  ширина линии  режим сплошная или пунктирная

//	Paint_DrawRectangle(20, 10, 70, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем прямоугольник пустотелый
//    Paint_DrawRectangle(85, 10, 130, 60, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем прямоугольник закрашенный

//	Paint_DrawCircle(170, 35, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_EMPTY);	// рисуем круг пустотелый
//    Paint_DrawCircle(170, 85, 20, BLACK, DOT_PIXEL_1X1, DRAW_FILL_FULL);	// рисуем круг закрашенный
//	
//	// печатаем строку параметры: х,  у,  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка
//	// для кирилицы используем функцию utf8rus, если только латиница то можно без нее
//	Paint_DrawString( 5, 85, BLACK, WHITE, 1, &Font_7x9, 1, "waveshare" );
//	// незабываем каждый раз после вызова функции utf8rus() освобождать память
//	// free( pText );	// освобождаем память выделенную в функции utf8rus() посредством malloc();
//	
//	// печатаем число
//	char str2[20];
//	sprintf(str2, "%d", 123456789 );
//	Paint_DrawString( 5, 110, BLACK, WHITE, 1, &Font_7x9, 1, str );

//	Paint_SetPixel( 190, 190, BLACK );	// рисуем 1 пиксель координаты и цвет
//	
//	// выводим на дисплей заполненый выше буффер
//	EPD_1IN54_V2_Display(BlackImage);
//    DEV_Delay_ms(2000);
////-------------------------------------------------------------

// эта функция используется для очистки части окна.
Paint_ClearWindows( 10, 10, 50, 50, WHITE);

// для дисплеев версий V2.0 необходимо использовать EPD_xxx_DisplayPartBaseImage для отображения статического изображения ( изображение оновляеться редко )
// а EPD_xxx_DisplayPart для отображения в режиме dymatic при частичном обновлении ( изображение оновляеться часто )
EPD_1IN54_V2_DisplayPart(BlackImage);
// EPD_1IN54_V2_DisplayPartBaseImage(BlackImage);

DEV_Delay_ms(2000);


//-----------------------------------------------------------------------------------------------


//--- частичное заполнение и отчистка части экрана --------------------------------------------------------

		for( int8_t i = 0; i < 10; i++){
			
				// эта функция используется для очистки части окна.
				Paint_ClearWindows( 10, 10, 10+Font_16x26.FontWidth, 10+Font_16x26.FontHeight, WHITE);
			
				// печатаем число
				char strI[2];
				sprintf(strI, "%d", i );
			
				// печатаем символ ( один ) параметры: х,  у,  цвет символа, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сам символ
				Paint_DrawString( 10, 10, BLACK, WHITE, 0, &Font_16x26, 1, strI );
			
				// для дисплеев версий V2.0 необходимо использовать EPD_xxx_DisplayPartBaseImage для отображения статического изображения ( изображение оновляеться редко )
				// а EPD_xxx_DisplayPart для отображения в режиме dymatic при частичном обновлении ( изображение оновляеться часто )
				EPD_1IN54_V2_DisplayPart(BlackImage);
				// EPD_1IN54_V2_DisplayPartBaseImage(BlackImage);
				
				DEV_Delay_ms(500);
			
				
		}

//-------------------------------------------------------------------------------------------------------------
	
		
	Paint_Clear(WHITE);
	// выводим на дисплей заполненый выше буффер
	EPD_1IN54_V2_Display(BlackImage);
		
	
//--------  рисуем свою картинку произвольного размера и в любом месте --------------------------------------------------------

		#include "bitmap.h"

		// вариант второй выводим любой размер картинки ( при етом выводит как есть белое белым  и черное черным )
		// данный метод также поддерживает ротацию и отзеркаливание
		// выводим любой размер картинки, начальные координаты, массив с картинкой, размер ширина и высота картинки, цвет
		Paint_DrawBitMap_Size( 10, 50, logo, 128, 27, BLACK );

		// выводим на дисплей заполненый выше буффер
		EPD_1IN54_V2_Display(BlackImage);	

		DEV_Delay_ms(2000);
//------------------------------------------------------------------------------------------------------------------------------
	

//----------  пишем по русски и английски  --------------------------------------------------------------------

		// печатаем символ ( один ) параметры: х,  у,  цвет символа, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сам символ
		Paint_DrawChar( 60, 60, BLACK, WHITE, 0, &Font_16x26, 3, 'F' );


		// печатаем строку параметры: х,  у,  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка
		// для кирилицы используем функцию utf8rus, если только латиница то можно без нее
		Paint_DrawString( 80, 150, BLACK, WHITE, 1, &Font_6x8, 1, utf8rus("Привет Дож") );
		// незабываем каждый раз после вызова функции utf8rus() освобождать память
		// free( pText );	// освобождаем память выделенную в функции utf8rus() посредством malloc();
		free( pText );
		
		// выводим на дисплей заполненый выше буффер
		EPD_1IN54_V2_Display(BlackImage);	

		DEV_Delay_ms(2000);
		
//-----------------------------------------------------------------------------------------------------------------



// переводим дисплей в спящий режим
EPD_1IN54_V2_Sleep();

// освобождаем память выделеную
free(BlackImage);
BlackImage = NULL;

// отключаем пины DC RST CS для экономии эллектричества
DEV_Module_Exit();	


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Если  экономим энергию нужно инициализировать дисплей нарисовать чтото потом уснуть и через время снова инициализировать  нарисовать и уснуть и так покругу
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

//############################################################################################################################################################








while(1)===========================================================================================================================

	.........
	.........
	.........
	.........

=== end while(1) ==================================================================================================================
=== end main() ====================================================================================================================
